<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <script>
    /* 43:给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
    */
    var multiply = function (num1, num2) {
      const len1 = num1.length;
      const len2 = num2.length;
      const result = new Array(len1 + len2).fill(0);
      for (let i = len1 - 1; i >= 0; i--) {
        for (let j = len2 - 1; j >= 0; j--) {
          const product = (num1[i] - '0') * (num1[i] - '0');
          const sum = product + result[i + j + 1];
          result[i + j + 1] = sum % 10;
          result[i + j] += Math.floor(sum / 10);
        }
      }
      while (result[0] === 0 && result.length > 1) {
        result.shift();
      }
      return result.join('');
    };
    console.log(multiply("123", "456"));

    /*44:通配符匹配：
    给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 '?' 和 '*' 匹配规则的通配符匹配：
    '?' 可以匹配任何单个字符。
    '*' 可以匹配任意字符序列（包括空字符序列）。
    判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。
  */
    var isMatch = function (s, p) {
      if (p) {

      }
    };

    /* 45:跳跃游戏：
    给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
    每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
    返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
    示例： nums = [2,3,1,1,4] 输出：2 
            说明：跳到最后一个位置的最小跳跃数是 2。
            从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置
          nums = [ 2,3,0,1,4] 输出：2
    */
    var jump = function (nums) {
      let curIndex = 0;
      let nextIndex = 0;
      let steps = 0;
      for (let i = 0; i < nums.length - 1; i++) {
        nextIndex = Math.max(nums[i] + i, nextIndex)
        if (i === curIndex) {
          curIndex = nextIndex
          steps++
        }
      }
      return steps
    };

    var jump = function (nums) {
      let res = 0, start = 0, end = 1;
      while (end < nums.length) {
        let tempMaxPos = 0;
        for (let i = start; i < end; ++i) {
          tempMaxPos = Math.max(i + nums[i], tempMaxPos);
        }
        start = end;
        end = tempMaxPos + 1;
        ++res;
      }
      return res;
    };






  </script>

</body>

</html>